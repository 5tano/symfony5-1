# Foundry Tricks

In `QuestionFactory`, we're already doing a pretty good job of making some of this
data random... so that all of our questions aren't identical. To help with this,
Foundry comes with built-in support for Faker: a library that's great at creating
all *kinds* of interesting, fake data.

## Using Faker

If you look at the top of the Foundry docs, you'll see a section called Faker and
a link to the [Faker documentation](https://github.com/fzaninotto/Faker). This
tells you everything that Faker can do... which is... a *lot*. Let's use this to
make our fake data even better.

For example, for this random -1 to -100 days, we can make it more readable by
replacing the `new \DateTime()` with `self::faker()`: that's how you can get an
instance of the `Faker` object. Then `->dateTimeBetween()` to go from `-100 days`
to `-1 day`. Nice! And because this is more flexible, we can even change it from
`-100 days` to `-1 minute`!

Even the random true/false condition at the beginning can be generated by Faker.
What we *really* want is to create published questions about 70% of the time. We
can do that with `self::faker()->boolean(70)`.

That will return true about 70% of the time.

This is cool, but the *real* problem is that the name and question of every
`Question` is... pretty much exactly the same. That is *definitely* not realistic.
Let's fix that: set `name` to `self::faker()->realText()` to get several words
of "real looking" text. For `slug`, there's a feature for that!
`self::faker()->slug`. Finally, for the question text, it can be made much more
interesting by using `self::faker->paragraphs()`.

Fake lets you use `paragraphs` like a property *or* you can call a function and
pass it an argument, which is the *number* of paragraphs and whether you want them
as text, which we do - otherwise it gives you an array. For the number of paragraphs,
we can use Faker again! `self::faker()->numberBetween(1, 4)` and then `true`
to return this as a string.

Let's take this for a test drive! Find your terminal, and reload the fixtures with:

```terminal
symfony console doctrine:fixtures:load
```

Go check the homepage and... boom!

Awesome! Oh, but the "real text" for the name is way too long. What I meant to
do is pass `->realText(50)`. Let's reload the fixtures again:

```terminal-silent
symfony console doctrine:fixtures:load
```

And... there we go! We now have *many* `Question` objects *and* they represent
a rich set of unique data. This is why I *love* Foundry.

## Doing Things Before Saving

If you click into one of the questions, you can see that the `slug` *is* unique...
but was generated in a way that is *completely* unrelated to the question's `name`.
That's "maybe" find... but not realistic. Could we fix that?

Of course!. Foundry comes with a really nice "hook" system, where you can do actions
before or after each item is saved. Inside `QuestionFactory`, it has
an `initialize()` method here, which is where you can *add* these hooks.

Remove the `slug` key from `getDefaults()` and, instead, down here, uncomment out
this `beforeInstantiate()` and change it to `afterInstantiate()`.

So `afterInstantiate()`, we want to run this function. Inside, we want to generate
a random slug based off of the name. We can do that by saying, if *not*
`$question->getSlug()` - just in case we set it manually for some reason - then
we can use a Slugger inside of Symfony `$slugger = new AsciiSlugger()` - and set
it with `$question->setSlug($slugger->slug())` passing `$question->getName()`

Nice! Let's try this. Move over, reload the fixtures again

```terminal-silent
symfony console doctrine:fixtures:load
```

And... go back to the homepage. Let's see: if I click the first one... yes! It
Works. It has some upper case letters... which we could normalize to lowercase.
But I'm not going to worry about that because, in a few minutes, we'll add an
even *better* way of generating slugs across our entire system.

## Foundry "State"

Let's try *one* last thing with Foundry. We know that, to have nice testing data,
we want a mixture of published and unpublished questions. We're currently
accomplishing that by randomly setting some `askedAt` properties to `null`.
Instead let's create two different *sets* of fixtures: exactly 20 that are
published and exactly 5 that are unpublished.

To do this, first remove the randomness from `askedAt` in `getDefaults()`: let's
*always* set this.

If we stop now, we would, of course, have 20 questions that are all published. But
now, add a new public function to the factory: `public function unpublished()`
that returns `self`.

I *totally* just made up that name. Inside, `return $this->addState()` and pass
it an array with `askedAt` set to null.

Here's the deal: when you call `addState()`, it *changes* the default data inside
this instance of the factory. The return statement here just helps to return
`self`... which will help us with method chaining.

To use this, go back to `AppFixtures`. Start with `QuestionFactory::new()` - to
get a second instance of `QuestionFactory` then `->unpublished()` to change the
default `askedAt` data. You can see why I called the method `unpublished()`: it
makes this super clear. Finish with `->createMany(5)`.

I *love* this! It reads like a story: create a new factory, make everything
everything unpublished and create 5.

Let's make sure we didn't break anything. At the terminal, reload the fixtures:

```terminal-silent
symfony console doctrine:fixtures:load
```

Then... refresh the homepage.

All good! If we dug into the database, we'd find 20 published questions and five
unpublished. Foundry can do more - especially with Doctrine relations and testing -
and we'll talk about Doctrine relations in the next tutorial.

But first, the `slug` property is being set automatically in our fixtures. That's
cool... but I'd *really* love for the slug to automatically be set to a URL-safe
version of the `name` no matter *where* I create a `Question` object. Basically,
I shouldn't *ever* need to worry about setting the slug manually.

So the next let's install a bundle that will give our entity Sluggable *and*
Timestampable superpowers.
