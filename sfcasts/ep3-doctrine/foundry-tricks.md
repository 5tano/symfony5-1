# Foundry Tricks

Coming soon...

In `QuestionFactory`, we're already doing a pretty good job of making some of this
data random so that all of our questions, oops, so that all of our questions aren't
identical Foundry comes with built in support for faker a library. That's great at
creating data. If you look at the top of the Foundry docs, you'll see a section
called faker and a link to the faker documentation. This tells you everything that
failure can do, and it can generate a lot of random data. We can use it to make our
data even better. For example, for this random minus one to minus 100 days here, we
can make this more readable by replacing the `new \DateTime()` with `self::faker()`
That's how you get the instance of faker ->dateTimeBetween()And we
want to go from `-100 days` to `-1 day`.

Nice. And because this is more flexible, we can even change it from `-100 days` to
`-1 minute`. Even the random number at the beginning can be generated by faker.
What we really want to do here is create published questions about 70% of the time,
replace the Rand with `self::faker()->boolean(70)`. That
means is 70% percent chance of returning a `true` boolean. This is cool, but the real
problem is that the name and question of every question is pretty much is exactly the
same. That is not realistic. Well, we can easily fix that with. I said he `name` two
`self::faker()->realText()`. We'll give you a kind of realistic looking
text and the `slug` to `self::faker()->slug`, and the texts be some can
be made much more interesting by using `self::faker->paragraphs()`

And you can just say paragraphs, or you can call a function. And then it takes a
number of arguments, the number of paragraphs, and whether you want to as text, which
we do, we won't otherwise it will return an array for the number of paragraphs I'm
going to use faker again, `self::faker()->numberBetween(1, 4)`
And then I'll say `true` so that it returns this as a string. Okay. Now let's
drive things back to your terminal. Reload your fixtures with 

```terminal
symfony console doctrine:fixtures:load
```

then go check out the home page. Boom.

That is much better, but actually my real text here is way too long. What I meant to
do here is pass `->realText(50)`. Let's reload our fixtures again, and there we go.
That's a little bit more realistic of a length and we have much better random data.
This is why I love Foundry reproducible great random data. Of course, if you look
over here, if I click on one of these, the slug that was generated is completely
unrelated to the name, which is fine, but could we fix that? Sure. Foundry comes with
a really nice hook system. If a, if you're looking at your question factory, it has
an initialized method here, which is where you can add different hooks. So let's
remove the slug key up here. And instead down here, I'm going to uncomment out this
`beforeInstantiate()` and change it to `afterInstantiate()`.

So after instantiate, we want to run this function. What we'll do here is we'll
generate this log based off of the name. We can do that by saying, if not, \
`$question->getSlug()` just in case we just to avoid overriding it. If we did set it for
some reason, then we can use a Slugger instead of Symfony `$slugger = new AsciiSlugger()`
and then `$question->setSlug($slugger->slug())`. And they'll say
`$question->getName()` nice. Let's try this. Move over. Reload the fixtures again

```terminal-silent
symfony console doctrine:fixtures:load
```

and then go back to the homepage. And let's see if I click the first one. Yes, it
works. It has some upper case letters here. So we could normalize that if we wanted
to, but I'm not going to worry about that because in a few minutes, we'll add a
better way of generating slugs across our entire system.

But this shows you the control that Foundry gives you. Alright, let's try one last
thing. We know that to have nice testing data, we want some published in some
unpublished questions. We're currently accomplishing that by randomly setting, some
`askedAt` properties to `null`, instead let's create two sets of fixtures. Let's
create exactly 20 published questions and then exactly five unpublished to do this
first, remove the randomness from `askedAt` and `getDefaults()`. Let's always set this. If
we stop now, we would of course have 20 questions that are all published, but now add
a new function, a new public function to the factory `public function unpublished()`
that returns `self`.

I totally just made up that name. It's a descriptive name that says, and you'll see
how it's used in a second inside `return $this->addState()` and pass it an array with
`askedAt` ad set to know when you call it state, it changes the default data inside
the, an instance of this factory. The return statement here just helps to return
self, which is going to help us with method chaining. Now, check this out in app
fixtures. We can say `QuestionFactory::new()` to get a second instance of
our `QuestionFactory`, then `->unpublished()` to change the default asset data. And
here you can see why I called it unpublished. It makes it read really well. And then
`->createMany(5)`, that reads like a story. Create a new factory. Make sure
everything's on published. Now create five of those. All right, let's make sure we
didn't break anything at your terminal. Reload. The fixtures 

```terminal-silent
symfony console doctrine:fixtures:load
```

then refresh the home
page. All good. If we dug into the database, we'd find 20 published questions in five
unpublished Fondrick can do more, especially with doctrine relations and testing.
We'll talk about doctrine relations in the next tutorial, but first the slug property
is being set automatically in our fixtures, but really we always want this to be set
automatically to a URL safe version of the name of our question, no matter where it's
being created, I shouldn't have to worry about setting the slug anywhere. So the next
let's install, bundle that will give our entity slugable superpowers.

